<chapter id="internals" xreflabel="internals">
	<title> Roll Internals </title>

<para>
This section describes in detail the two major components of a roll: packages
and configuration files.
</para>


<section id="internals-roll-env" xreflabel="internals-roll-env">
        <title> Roll Development Environment </title>

<para>
In this section, we'll build an example roll (the "valgrind" roll) from the
ground up.
</para>

<para>
First, we need to create a development environment that can be used to build
the "valgrind" roll.
On a Rocks frontend, execute:
</para>

<screen>
# mkdir -p /export/src/roll
# cd /export/src/roll
# rocks create new roll name=valgrind
</screen>

<para>
There are several more options you can supply to
<constant>"rocks create new roll"</constant> (execute
<constant>"rocks create new roll help"</constant> to see all the options).
</para>

<para>
The command <constant>"rocks create new roll name=valgrind"</constant>
creates the following file system:
</para>

<screen>
valgrind -+
          |
          +- graphs -+
          |
          +- nodes -+
          |
          +- src -+
          |
          +- version.mk
          |
          +- Makefile
</screen>

<para>
Now we are ready to add packages to the valgrind roll.
</para>


</section>


<section id="internals-packages" xreflabel="internals-packages">
        <title>Packages</title>

<para>
A Rocks roll requires that all packages contained in the roll must be in the
native format of the OS.
For Redhat-based Rocks clusters, this means all packages must be RPMS.
</para>


<section id="internals-packages-rpm" xreflabel="internals-packages-rpm">
        <title>The Software is Already in an RPM </title>

<para>
If the software you wish to install is already in RPM format, you can directly
put it into the roll source tree.
For example, to put the RPM <constant>unzip-5.52-3.el5.x86_64.rpm</constant>
into the valgrind roll, execute:
</para>

<screen>
# mkdir -p /export/src/roll/valgrind/RPMS/x86_64
# cp /tmp/unzip-5.52-3.el5.x86_64.rpm /export/src/roll/valgrind/RPMS/x86_64
</screen>

</section>


<section id="internals-packages-bundle" xreflabel="internals-packages-bundle">
        <title>Bundle an Existing Subdirectory into an RPM </title>

<para>
If your application is already installed on your frontend and you would like
to bundle its subdirectory into and RPM, you can
create an RPM that contains all the files in a subdirectory.
For example, let's say you want to create an RPM from all the files under
/opt/stream.
You can execute:
</para>

<screen>
# rocks create package /opt/stream stream
</screen>

<para>
This will create a package named <constant>stream-1.0-1.x86_64.rpm</constant>
in the current working directory.
To see the contents of the package, execute:
</para>

<screen>
# rpm -qlp stream-1.0-1.x86_64.rpm 
/
/opt
/opt/stream
/opt/stream/bin
/opt/stream/bin/stream
/opt/stream/bin/stream_f
/opt/stream/docs
/opt/stream/docs/HISTORY.txt
/opt/stream/docs/LICENSE.txt
/opt/stream/docs/Makefile
/opt/stream/docs/READ.ME
/opt/stream/docs/ROCKS.txt
/opt/stream/docs/linux.mk
/opt/stream/docs/mysecond.c
/opt/stream/docs/stream.c
/opt/stream/docs/stream.f
/opt/stream/docs/sunos.mk
/opt/stream/docs/version.mk
</screen>

<para>
There are several more options you can supply to
<constant>"rocks create package"</constant> (execute
<constant>"rocks create package help"</constant> to see all the options).
</para>

<para>
Now place the RPM into the correct directory within the roll:
</para>

<screen>
# mkdir -p /export/src/roll/valgrind/RPMS/x86_64
# cp stream-1.0-1.x86_64.rpm /export/src/roll/valgrind/RPMS/x86_64
</screen>


</section>


<section id="internals-packages-src" xreflabel="internals-packages-src">
        <title>Create an RPM from a Source Code Tarball </title>

<para>
The most common way we create RPMS is from source tarballs (the classic:
untar, configure, make, make install).
</para>

<para>
First, we'll download the source tarball into the correct directory:
</para>

<screen>
# cd /export/src/roll/valgrind/src/valgrind
# wget http://valgrind.org/downloads/valgrind-3.6.0.tar.bz2
</screen>

<para>
Edit <constant>version.mk</constant> and change
<constant>TARBALL_POSTFIX = tgz</constant> to
<constant>TARBALL_POSTFIX = tar.bz2</constant>, change
<constant>PKGROOT = /opt/valgrind</constant> to
<constant>PKGROOT = /opt</constant>,and change
<constant>VERSION = 1.0</constant> to
<constant>VERSION = 3.6.0</constant>.
Your version.mk should look like:
</para>

<screen>
PKGROOT		= /opt
NAME    	= valgrind
VERSION 	= 3.6.0
RELEASE 	= 1
TARBALL_POSTFIX	= tar.bz2
</screen>

<para>
Edit <constant>Makefile</constant> and change the line:
<constant>gunzip -c</constant> to
<constant>bzcat</constant> (since the tarball is a bz2).
</para>

<para>
Now build the RPM:
</para>

<screen>
# make rpm
</screen>

<para>
It will take several minutes to build the package.
When it completes, you'll see the line:
</para>

<screen>
Wrote: /export/src/roll/valgrind/RPMS/x86_64/valgrind-3.6.0-1.x86_64.rpm
</screen>

<para>
You can inspect the contents of the <constant>valgrind</constant> RPM:
</para>

<screen>
# rpm -qlp /export/src/roll/valgrind/RPMS/x86_64/valgrind-3.6.0-1.x86_64.rpm
/
/opt
/opt/valgrind
/opt/valgrind/bin
/opt/valgrind/bin/callgrind_annotate
/opt/valgrind/bin/callgrind_control
/opt/valgrind/bin/cg_annotate
/opt/valgrind/bin/cg_diff
/opt/valgrind/bin/cg_merge
/opt/valgrind/bin/ms_print
/opt/valgrind/bin/no_op_client_for_valgrind
/opt/valgrind/bin/valgrind
/opt/valgrind/bin/valgrind-listener
/opt/valgrind/include
/opt/valgrind/include/valgrind
/opt/valgrind/include/valgrind/callgrind.h
   .
   .
   .
</screen>

<para>
Note that the valgrind-3.6.0-1.x86_64.rpm RPM was automatically placed into
the correct directory (/export/src/roll/valgrind/RPMS/x86_64).
</para>

</section>



</section>


<section id="internals-xml-files" xreflabel="internals-xml-files">
        <title>Configuring Software with XML Files</title>

<para>
Rocks generates kickstart files for compute nodes dynamically using a
structure called the "kickstart graph".
This graph is made from graph XML files and node XML files.
In general, a node XML file contains a list of packages that should be
installed on a host and commands to configure those packages.
Graph XML files contain a description of "edges" that tie the node XML files
together.
</para>

<para>
When a host asks for its configuration file from the frontend, a process on
the frontend traverses the node XML files based on the definitions within the
graph XML files.
In addition, the graph XML files can enforce a relative order between the
node XML files.
</para>


<section id="internals-xml-files-node" xreflabel="internals-xml-files-node">
        <title>Node XML Files</title>

<para>
All software configuration commands are contained within node XML files.
Let's look at a real node XML (grub.xml from the base roll):
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

  <description>

  Boot loader support (GRand Unified Bootloader)

  </description>


<package>grub</package>


<post>

<!-- take out the splashscreen -->
<file name="/tmp/grub.conf" expr="grep -v splashimage /boot/grub/grub.conf"/>
mv /tmp/grub.conf /boot/grub/grub.conf

<!-- Preserve the original grub.conf -->
cp /boot/grub/grub.conf /boot/grub/grub-orig.conf

</post>


</kickstart>
]]>
</screen>

<para>
We see that the above node file will install the "grub" package
(<constant>&lt;package&gt;grub&lt;/package&gt;</constant>), and in the
"post" configuration step during a kickstart installation, it will
modify the configuration file (<constant>/boot/grub/grub.conf</constant>).
</para>

<note>
<para>
In kickstart installation, all the packages from all the node XML files are
installed first, then all the "post" sections are executed.
That is, when you write a post section, you are guaranteed that all the
software packages have been installed.
</para>
</note>

<para>
For a complete definition of the node XML file syntax, see
<xref linkend="node-xml-tags">.
</para>

<para>
For our "valgrind" example, we will modify the node file that was already
created for us:
</para>

<screen>
# cd /export/src/roll/valgrind/nodes
# mv valgrind.xml valgrind-base.xml
</screen>

<note>
<para>
A node naming convention in Rocks is to begin the name all the node files with
the name of the roll they are associated with.
For example, all node files in the SGE roll begin with "sge-".
</para>

<para>
Another naming convention is to add the name "client", "server" or "base" to
the name of node file based on which appliance type the node file will be
applied to.
For example, if the node file is intended to configure only backend
appliances (e.g., compute nodes or tile nodes), then we'd name our node file
"valgrind-client.xml".
If the node file is intended to configure only frontend appliances, then we'd
name our node file "valgrind-server.xml".
And if the node file is for all appliance types, we'd name it
"valgrind-base.xml". 
</para>
</note>

<para>
When you edit "valgrind-base.xml", you'll see:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>


        <description>
        Your valgrind roll description here
        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <package>valgrind</package>
        <package>roll-valgrind-usersguide</package>


</kickstart>
]]>
</screen>

<para>
Notice above that the "valgrind" and "roll-valgrind-usersguide" RPMs
are specified in &lt;package&gt; tags which means those RPMs will be installed 
by the Red Hat installer.
</para>

<para>
Now let's add a &lt;post&gt; section to it:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>


        <description>
        Your valgrind roll description here
        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <package>valgrind</package>
        <package>roll-valgrind-usersguide</package>

<post>

<file name="/etc/motd" mode="append">

This node has "valgrind" configured for it.

</file>

</post>

</kickstart>

]]>
</screen>

<para>
This post section will append a small note to an installing host's /etc/motd.
</para>

<para>
Now that we have our first node XML file, we need to "splice" it into the
Rocks kickstart graph -- which is the subject of the next section.
</para>


</section>


<section id="internals-xml-files-graph" xreflabel="internals-xml-files-graph">
        <title>Graph XML Files</title>

<para>
Every roll has node XML files and graph XML files.
Node XML files describe what packages should be installed and how those
packages should be configured.
Graph XML files describe how all the node XML files are "connected" -- a
graph XML file describes the "edges" between nodes.
</para>

<para>
Below is a picture of how the Base roll's nodes are connected together via
its graph XML file:
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-graph.png">
	</imageobject>
</mediaobject>
</para>

<para>
Let's "splice" our "valgrind-base.xml" node XML file into the Rocks kickstart
graph.
We'll look at the default graph file that was automatically created for us:
</para>

<screen>
# cd /export/src/roll/valgrind/graphs/default
</screen>

<para>
Now edit the file "valgrind.xml":
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

</graph>
]]>
</screen>

<para>
We will add an "edge" to this file.
Since we want our "valgrind-base.xml" node XML file to be installed on all
nodes, we'll make an edge from the "base" node XML file to ours:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

        <edge from="base">
                <to>valgrind-base</to>
        </edge>

</graph>
]]>
</screen>

<note>
<para>
Note that we don't add the ".xml" file extension in edge descriptions.
</para>
</note>

<para>
Our node XML file has now been spliced into the Rocks kickstart graph.
Note: the node XML file "base" is from the Base roll.
</para>

<para>
Now suppose we want to create 2 new node XML files where one file should be
applied to a frontend installation and the other should be applied to the
backend appliances.
We'll create a new node XML file for frontends named "valgrind-server.xml" and
a new node XML file named "valgrind-client.xml" for the backend appliances.
We'll add &lt;package&gt; and &lt;post&gt; tags to both.
Then, to splice them in to the Rocks kickstart graph, we'll modify our
graph XML file "valgrind.xml" to look like:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

        <edge from="base">
                <to>valgrind-base</to>
        </edge>

        <edge from="server">
                <to>valgrind-server</to>
        </edge>

        <edge from="client">
                <to>valgrind-client</to>
        </edge>

</graph>
]]>
</screen>

<para>
With the above graph XML file, we can see (at a high level) how the Valgrind
roll is spliced in with the Base roll:
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-valgrind-graph.png">
	</imageobject>
</mediaobject>
</para>


</section>


<section id="internals-xml-files-attr" xreflabel="internals-xml-files-attr">
        <title>Attributes</title>

<para>
Global, OS, appliance and host attributes.
</para>

</section>


</section>


</chapter>
