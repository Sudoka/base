<chapter id="internals" xreflabel="internals">
	<title> Roll Internals </title>

<para>
This section describes in detail the two major components of a roll: packages
and configuration files.
</para>


<section id="internals-roll-env" xreflabel="internals-roll-env">
        <title> Roll Development Environment </title>

<para>
In this section, we'll build an example roll (the "valgrind" roll) from the
ground up.
</para>

<para>
First, we need to create a development environment that can be used to build
the "valgrind" roll.
On a Rocks frontend, execute:
</para>

<screen>
# mkdir -p /export/src/roll
# cd /export/src/roll
# rocks create new roll name=valgrind
</screen>

<para>
There are several more options you can supply to
<constant>"rocks create new roll"</constant> (execute
<constant>"rocks create new roll help"</constant> to see all the options).
</para>

<para>
The command <constant>"rocks create new roll name=valgrind"</constant>
creates the following file system:
</para>

<screen>
valgrind -+
          |
          +- graphs -+
          |
          +- nodes -+
          |
          +- src -+
          |
          +- version.mk
          |
          +- Makefile
</screen>

<para>
Now we are ready to add packages to the valgrind roll.
</para>


</section>


<section id="internals-packages" xreflabel="internals-packages">
        <title>Packages</title>

<para>
A Rocks roll requires that all packages contained in the roll must be in the
native format of the OS.
For Redhat-based Rocks clusters, this means all packages must be RPMS.
</para>


<section id="internals-packages-rpm" xreflabel="internals-packages-rpm">
        <title>The Software is Already in an RPM </title>

<para>
If the software you wish to install is already in RPM format, you can directly
put it into the roll source tree.
For example, to put the RPM <constant>unzip-5.52-3.el5.x86_64.rpm</constant>
into the valgrind roll, execute:
</para>

<screen>
# mkdir -p /export/src/roll/valgrind/RPMS/x86_64
# cp /tmp/unzip-5.52-3.el5.x86_64.rpm /export/src/roll/valgrind/RPMS/x86_64
</screen>

</section>


<section id="internals-packages-bundle" xreflabel="internals-packages-bundle">
        <title>Bundle an Existing Subdirectory into an RPM </title>

<para>
If your application is already installed on your frontend and you would like
to bundle its subdirectory into and RPM, you can
create an RPM that contains all the files in a subdirectory.
For example, let's say you want to create an RPM from all the files under
/opt/stream.
You can execute:
</para>

<screen>
# rocks create package /opt/stream stream
</screen>

<para>
This will create a package named <constant>stream-1.0-1.x86_64.rpm</constant>
in the current working directory.
To see the contents of the package, execute:
</para>

<screen>
# rpm -qlp stream-1.0-1.x86_64.rpm 
/
/opt
/opt/stream
/opt/stream/bin
/opt/stream/bin/stream
/opt/stream/bin/stream_f
/opt/stream/docs
/opt/stream/docs/HISTORY.txt
/opt/stream/docs/LICENSE.txt
/opt/stream/docs/Makefile
/opt/stream/docs/READ.ME
/opt/stream/docs/ROCKS.txt
/opt/stream/docs/linux.mk
/opt/stream/docs/mysecond.c
/opt/stream/docs/stream.c
/opt/stream/docs/stream.f
/opt/stream/docs/sunos.mk
/opt/stream/docs/version.mk
</screen>

<para>
There are several more options you can supply to
<constant>"rocks create package"</constant> (execute
<constant>"rocks create package help"</constant> to see all the options).
</para>

<para>
Now place the RPM into the correct directory within the roll:
</para>

<screen>
# mkdir -p /export/src/roll/valgrind/RPMS/x86_64
# cp stream-1.0-1.x86_64.rpm /export/src/roll/valgrind/RPMS/x86_64
</screen>


</section>


<section id="internals-packages-src"
	xreflabel="Create an RPM from a Source Code Tarball">
        <title>Create an RPM from a Source Code Tarball</title>

<para>
The most common way we create RPMS is from source tarballs (the classic:
untar, configure, make, make install).
</para>

<para>
First, we'll download the source tarball into the correct directory:
</para>

<screen>
# cd /export/src/roll/valgrind/src/valgrind
# wget http://valgrind.org/downloads/valgrind-3.6.0.tar.bz2
</screen>

<para>
Edit <constant>version.mk</constant> and change
<constant>TARBALL_POSTFIX = tgz</constant> to
<constant>TARBALL_POSTFIX = tar.bz2</constant>, change
<constant>PKGROOT = /opt/valgrind</constant> to
<constant>PKGROOT = /opt</constant>,and change
<constant>VERSION = 1.0</constant> to
<constant>VERSION = 3.6.0</constant>.
Your version.mk should look like:
</para>

<screen>
PKGROOT		= /opt
NAME    	= valgrind
VERSION 	= 3.6.0
RELEASE 	= 1
TARBALL_POSTFIX	= tar.bz2
</screen>

<para>
Edit <constant>Makefile</constant> and change the line:
<constant>gunzip -c</constant> to
<constant>bzcat</constant> (since the tarball is a bz2).
</para>

<para>
Now build the RPM:
</para>

<screen>
# make rpm
</screen>

<para>
It will take several minutes to build the package.
When it completes, you'll see the line:
</para>

<screen>
Wrote: /export/src/roll/valgrind/RPMS/x86_64/valgrind-3.6.0-1.x86_64.rpm
</screen>

<para>
You can inspect the contents of the <constant>valgrind</constant> RPM:
</para>

<screen>
# rpm -qlp /export/src/roll/valgrind/RPMS/x86_64/valgrind-3.6.0-1.x86_64.rpm
/
/opt
/opt/valgrind
/opt/valgrind/bin
/opt/valgrind/bin/callgrind_annotate
/opt/valgrind/bin/callgrind_control
/opt/valgrind/bin/cg_annotate
/opt/valgrind/bin/cg_diff
/opt/valgrind/bin/cg_merge
/opt/valgrind/bin/ms_print
/opt/valgrind/bin/no_op_client_for_valgrind
/opt/valgrind/bin/valgrind
/opt/valgrind/bin/valgrind-listener
/opt/valgrind/include
/opt/valgrind/include/valgrind
/opt/valgrind/include/valgrind/callgrind.h
   .
   .
   .
</screen>

<para>
Note that the valgrind-3.6.0-1.x86_64.rpm RPM was automatically placed into
the correct directory (/export/src/roll/valgrind/RPMS/x86_64).
</para>

</section>



</section>


<section id="internals-xml-files" xreflabel="internals-xml-files">
        <title>Configuring Software with XML Files</title>

<para>
Rocks generates kickstart files for compute nodes dynamically using a
structure called the "kickstart graph".
This graph is made from graph XML files and node XML files.
In general, a node XML file contains a list of packages that should be
installed on a host and commands to configure those packages.
Graph XML files contain a description of "edges" that tie the node XML files
together.
</para>

<para>
When a host asks for its configuration file from the frontend, a process on
the frontend traverses the node XML files based on the definitions within the
graph XML files.
In addition, the graph XML files can enforce a relative order between the
node XML files.
</para>


<section id="internals-xml-files-node" xreflabel="internals-xml-files-node">
        <title>Node XML Files</title>

<para>
All software configuration commands are contained within node XML files.
Let's look at a real node XML (grub.xml from the base roll):
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

  <description>

  Boot loader support (GRand Unified Bootloader)

  </description>


<package>grub</package>


<post>

<!-- take out the splashscreen -->
<file name="/tmp/grub.conf" expr="grep -v splashimage /boot/grub/grub.conf"/>
mv /tmp/grub.conf /boot/grub/grub.conf

<!-- Preserve the original grub.conf -->
cp /boot/grub/grub.conf /boot/grub/grub-orig.conf

</post>


</kickstart>
]]>
</screen>

<para>
We see that the above node file will install the "grub" package
(<constant>&lt;package&gt;grub&lt;/package&gt;</constant>), and in the
"post" configuration step during a kickstart installation, it will
modify the configuration file (<constant>/boot/grub/grub.conf</constant>).
</para>

<note>
<para>
In kickstart installation, all the packages from all the node XML files are
installed first, then all the "post" sections are executed.
That is, when you write a post section, you are guaranteed that all the
software packages have been installed.
</para>
</note>

<para>
For a complete definition of the node XML file syntax, see
<xref linkend="node-xml-tags">.
</para>

<para>
For our "valgrind" example, we will modify the node file that was already
created for us:
</para>

<screen>
# cd /export/src/roll/valgrind/nodes
# mv valgrind.xml valgrind-base.xml
</screen>

<note>
<para>
A node naming convention in Rocks is to begin the name all the node files with
the name of the roll they are associated with.
For example, all node files in the SGE roll begin with "sge-".
</para>

<para>
Another naming convention is to add the name "client", "server" or "base" to
the name of node file based on which appliance type the node file will be
applied to.
For example, if the node file is intended to configure only backend
appliances (e.g., compute nodes or tile nodes), then we'd name our node file
"valgrind-client.xml".
If the node file is intended to configure only frontend appliances, then we'd
name our node file "valgrind-server.xml".
And if the node file is for all appliance types, we'd name it
"valgrind-base.xml". 
</para>
</note>

<para>
When you edit "valgrind-base.xml", you'll see:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

        <description>
        Your valgrind roll description here
        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.6  2011/02/07 23:30:26  bruno
        first pass at build section

        Revision 1.5  2011/02/07 20:48:46  bruno
        the first draft of 'roll internals' is done.

        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <package>valgrind</package>
        <package>roll-valgrind-usersguide</package>

</kickstart>
]]>
</screen>

<para>
Notice above that the "valgrind" and "roll-valgrind-usersguide" RPMs
are specified in &lt;package&gt; tags which means those RPMs will be installed 
by the Red Hat installer.
</para>

<para>
Now let's add a &lt;post&gt; section to it:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

        <description>
        Your valgrind roll description here
        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.6  2011/02/07 23:30:26  bruno
        first pass at build section

        Revision 1.5  2011/02/07 20:48:46  bruno
        the first draft of 'roll internals' is done.

        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <package>valgrind</package>
        <package>roll-valgrind-usersguide</package>

<post>

<file name="/etc/motd" mode="append">

This node has "valgrind" configured for it.

</file>

</post>

</kickstart>

]]>
</screen>

<para>
This post section will append a small note to an installing host's /etc/motd.
</para>

<para>
Now that we have our first node XML file, we need to "splice" it into the
Rocks kickstart graph -- which is the subject of the next section.
</para>


</section>


<section id="internals-xml-files-graph" xreflabel="internals-xml-files-graph">
        <title>Graph XML Files</title>

<para>
Every roll has node XML files and a graph XML file.
Node XML files describe what packages should be installed and how those
packages should be configured.
A graph XML file describes how all the node XML files are "connected", that is,
a graph XML file describes the "edges" between nodes.
</para>

<para>
Below is a picture of how the Base roll's nodes are connected together via
its graph XML file:
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-graph.png">
	</imageobject>
</mediaobject>
</para>

<para>
Let's "splice" our "valgrind-base.xml" node XML file into the Rocks kickstart
graph.
We'll look at the default graph file that was automatically created for us:
</para>

<screen>
# cd /export/src/roll/valgrind/graphs/default
</screen>

<para>
Now edit the file "valgrind.xml":
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.6  2011/02/07 23:30:26  bruno
        first pass at build section

        Revision 1.5  2011/02/07 20:48:46  bruno
        the first draft of 'roll internals' is done.

        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

</graph>
]]>
</screen>

<para>
We will add an "edge".
Since we want our "valgrind-base.xml" node XML file to be installed on all
nodes, we'll make an edge from the "base" node XML file to ours:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.6  2011/02/07 23:30:26  bruno
        first pass at build section

        Revision 1.5  2011/02/07 20:48:46  bruno
        the first draft of 'roll internals' is done.

        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

        <edge from="base">
                <to>valgrind-base</to>
        </edge>

</graph>
]]>
</screen>

<note>
<para>
Note that we don't add the ".xml" file extension in edge descriptions.
</para>
</note>

<para>
Our node XML file has now been spliced into the Rocks kickstart graph.
Note: the node XML file "base" is from the Base roll.
</para>

<para>
In the picture below, we see how "valgrind-base.xml" has been spliced into
the Rocks kickstart graph:
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-valgrind-simple-graph.png">
	</imageobject>
</mediaobject>
</para>


<section id="internals-xml-files-graph-ordering"
	xreflabel="internals-xml-files-graph-ordering">

        <title>Controlling the Order of Post Section Execution</title>

<para>
There are instances when we need to ensure that a post section in one
node XML file executes before (or after) a post section in another node XML
file.
We can accomplish this by specifying an &lt;order&gt; tag in a graph XML
file.
To show how this is done, we'll create 2 new node XML files and then we'll
edit the graph XML file.
</para>

<para>
We will create 2 new node XML files where one file should be
applied to a frontend (named "valgrind-server.xml") and the other should be
applied to the backend appliances (named "valgrind-client.xml).
We'll add &lt;package&gt; and &lt;post&gt; tags to both.
</para>

<para>
Here's the contents of "valgrind-client.xml":
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

	<description>
	Valgrind client node XML file. This file should be applied to
	backend appliances (e.g., compute nodes and tile nodes).
	</description>

	<copyright>
	Copyright (c) 2000 - 2010 The Regents of the University of California.
	All rights reserved. Rocks(r) v5.4 www.rocksclusters.org
	
	</copyright>

	<changelog>
	$Log: internals.sgml,v $
	Revision 1.6  2011/02/07 23:30:26  bruno
	first pass at build section
	
	Revision 1.5  2011/02/07 20:48:46  bruno
	the first draft of 'roll internals' is done.
	
	</changelog>

<post>

<file name="/etc/motd" mode="append">

Valgrind on a "client".

</file>

</post>

</kickstart>
]]>
</screen>

<para>
And here is the contents of "valgrind-server.xml":
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<kickstart>

	<description>
	Valgrind server node XML file. This file should be applied to
	frontends.
	</description>

	<copyright>
	Copyright (c) 2000 - 2010 The Regents of the University of California.
	All rights reserved. Rocks(r) v5.4 www.rocksclusters.org
	
	</copyright>

	<changelog>
	$Log: internals.sgml,v $
	Revision 1.6  2011/02/07 23:30:26  bruno
	first pass at build section
	
	Revision 1.5  2011/02/07 20:48:46  bruno
	the first draft of 'roll internals' is done.
	
	</changelog>

	<package>roll-valgrind-usersguide</package>

<post>

<file name="/etc/motd" mode="append">

Valgrind on a "server".

</file>

</post>

</kickstart>
]]>
</screen>

<para>
Then, to splice them in to the Rocks kickstart graph, we'll modify our
graph XML file "valgrind.xml" to look like:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph>

        <description>

        The valgrind Roll

        </description>

        <copyright>
        Copyright (c) 2000 - 2010 The Regents of the University of California.
        All rights reserved. Rocks(r) v5.4 www.rocksclusters.org

        </copyright>

        <changelog>
        $Log: internals.sgml,v $
        Revision 1.6  2011/02/07 23:30:26  bruno
        first pass at build section

        Revision 1.5  2011/02/07 20:48:46  bruno
        the first draft of 'roll internals' is done.

        Revision 1.4  2011/02/05 01:04:49  bruno
        checkpoint

        </changelog>

        <!-- add edges here -->

        <edge from="base">
                <to>valgrind-base</to>
        </edge>

        <edge from="server">
                <to>valgrind-server</to>
        </edge>

        <edge from="client">
                <to>valgrind-client</to>
        </edge>

</graph>
]]>
</screen>

<para>
With the above graph XML file, we can see (at a high level) how the Valgrind
roll is spliced in with the Base roll.
The Base Roll node XML files are yellow and the Valgrind Roll
node XML files are red.
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-valgrind-graph.png">
	</imageobject>
</mediaobject>
</para>

<para>
If we zoom in, we can see how tow of the valgrind node XML files have been
spliced in:
</para>

<para>
<mediaobject>
	<imageobject>
	<imagedata
		fileref="images/base-valgrind-zoom.png">
	</imageobject>
</mediaobject>
</para>

<para>
Now suppose we want the post section of "valgrind-server.xml" to execute
<emphasis>before</emphasis> the post section of "valgrind-base.xml" and we
want the post section of "valgrind-client.xml" to execute
<emphasis>after</emphasis> "valgrind-base.xml".
We can enforce this ordering by adding two &lt;order&gt; tags:
</para>

<screen>
<![CDATA[
<?xml version="1.0" standalone="no"?>

<graph roll="valgrind">

	<description>

	The valgrind Roll

	</description>

	<copyright>
	Copyright (c) 2000 - 2010 The Regents of the University of California.
	All rights reserved. Rocks(r) v5.4 www.rocksclusters.org
	
	</copyright>

	<changelog>
	$Log: internals.sgml,v $
	Revision 1.6  2011/02/07 23:30:26  bruno
	first pass at build section
	
	Revision 1.5  2011/02/07 20:48:46  bruno
	the first draft of 'roll internals' is done.
	
	</changelog>

	<!-- add edges here -->

	<edge from="base">
		<to>valgrind-base</to>
	</edge>

	<edge from="server">
		<to>valgrind-server</to>
	</edge>

	<edge from="client">
		<to>valgrind-client</to>
	</edge>


	<!-- enforce post section ordering -->

	<!--
		valgrind-server post sections execute before valgrind-base
		post sections
	-->
	<order head="valgrind-server">
		<tail>valgrind-base</tail>
	</order>

	<!--
		valgrind-client post sections execute after valgrind-base
		post sections
	-->
	<order head="valgrind-base">
		<tail>valgrind-client</tail>
	</order>

</graph>
]]>
</screen>

</section>

</section>


<section id="internals-xml-files-attr" xreflabel="internals-xml-files-attr">
        <title>Attributes</title>

<para>
In Rocks, "attributes" are a way to have variables inside node and graph
XML files.
Attributes are evaluated during kickstart file creation (one of the first
actions done when a host is installed).
The following is an example of how the 'hostname' attribute is used in a
post section of a node XML file:
</para>

<screen>
<![CDATA[
<post>

<!--
        set the hostname to the private name.
-->
/bin/hostname &hostname;

</post>
]]>
</screen>

<para>
In node XML files, if you want to use an attribute in a post section, you
need to encode it as an XML entity (thus the '&' and ';' characters that
bracket the 'hostname' attribute.
</para>

<para>
There are four levels of attributes: global, OS, appliance and host.
Global attributes apply to all hosts in a cluster, OS attributes apply to hosts of a specific OS type (currently "linux" or "sunos"), appliance attributes
apply to hosts that have the same appliance type (e.g., compute, tile, etc.),
and host attributes apply to only one host.
You can add an attribute with one of the following commands:
<constant>rocks add attr</constant> (global),
<constant>rocks add os attr</constant> (OS),
<constant>rocks add appliance attr</constant> (appliance global),
<constant>rocks add host attr</constant> (host).
</para>

<para>
To examine which attributes are currently set for a host, execute
<constant>rocks list host attr "hostname"</constant>.
For example:
</para>

<screen>
<![CDATA[
# rocks list host attr compute-0-0
HOST         ATTR                                  VALUE                                    SOURCE
compute-0-0: Condor_Client                         true                                     A     
compute-0-0: Condor_Daemons                        MASTER, STARTD                           G     
compute-0-0: Condor_EnableMPI                      no                                       G     
compute-0-0: Condor_HostAllow                      +                                        G     
compute-0-0: Condor_Master                         brunoland.rocksclusters.org              G     
compute-0-0: Condor_Network                        private                                  G     
compute-0-0: Condor_PasswordAuth                   no                                       G     
compute-0-0: Condor_PortHigh                       50000                                    G     
compute-0-0: Condor_PortLow                        40000                                    G     
compute-0-0: HttpConf                              /etc/httpd/conf                          O     
compute-0-0: HttpConfigDirExt                      /etc/httpd/conf.d                        O     
compute-0-0: HttpRoot                              /var/www/html                            O     
compute-0-0: Info_CertificateCountry               US                                       G     
compute-0-0: Info_CertificateLocality              San Diego                                G     
compute-0-0: Info_CertificateOrganization          SDSC                                     G     
compute-0-0: Info_CertificateState                 California                               G     
compute-0-0: Info_ClusterContact                   admin@place.org                          G     
compute-0-0: Info_ClusterLatlong                   N32.87 W117.22                           G     
compute-0-0: Info_ClusterName                      Brunoland                                G     
compute-0-0: Info_ClusterURL                       http://www.place.org/                    G     
compute-0-0: Kickstart_DistroDir                   /export/rocks                            G     
compute-0-0: Kickstart_Keyboard                    us                                       G     
compute-0-0: Kickstart_Lang                        en_US                                    G     
compute-0-0: Kickstart_Langsupport                 en_US                                    G     
compute-0-0: Kickstart_Multicast                   231.253.121.191                          G     
compute-0-0: Kickstart_PrivateAddress              10.1.1.1                                 G     
compute-0-0: Kickstart_PrivateBroadcast            10.1.255.255                             G     
compute-0-0: Kickstart_PrivateDNSDomain            local                                    G     
compute-0-0: Kickstart_PrivateDNSServers           10.1.1.1                                 G     
compute-0-0: Kickstart_PrivateGateway              10.1.1.1                                 G     
compute-0-0: Kickstart_PrivateHostname             brunoland                                G     
compute-0-0: Kickstart_PrivateKickstartBasedir     install                                  G     
compute-0-0: Kickstart_PrivateKickstartCGI         sbin/kickstart.cgi                       G     
compute-0-0: Kickstart_PrivateKickstartHost        10.1.1.1                                 G     
compute-0-0: Kickstart_PrivateNTPHost              10.1.1.1                                 G     
compute-0-0: Kickstart_PrivateNetmask              255.255.0.0                              G     
compute-0-0: Kickstart_PrivateNetmaskCIDR          16                                       G     
compute-0-0: Kickstart_PrivateNetwork              10.1.0.0                                 G     
compute-0-0: Kickstart_PrivateSyslogHost           10.1.1.1                                 G     
compute-0-0: Kickstart_PublicAddress               198.202.88.152                           G     
compute-0-0: Kickstart_PublicBroadcast             198.202.88.255                           G     
compute-0-0: Kickstart_PublicDNSDomain             rocksclusters.org                        G     
compute-0-0: Kickstart_PublicDNSServers            198.202.75.26                            G     
compute-0-0: Kickstart_PublicGateway               198.202.88.20                            G     
compute-0-0: Kickstart_PublicHostname              brunoland.rocksclusters.org              G     
compute-0-0: Kickstart_PublicKickstartHost         central.rocksclusters.org                G     
compute-0-0: Kickstart_PublicNTPHost               pool.ntp.org                             G     
compute-0-0: Kickstart_PublicNetmask               255.255.255.0                            G     
compute-0-0: Kickstart_PublicNetmaskCIDR           24                                       G     
compute-0-0: Kickstart_PublicNetwork               198.202.88.0                             G     
compute-0-0: Kickstart_Timezone                    America/Los_Angeles                      G     
compute-0-0: RootDir                               /root                                    O     
compute-0-0: Server_Partitioning                   manual                                   G     
compute-0-0: Xen_Dom0MinMem                        768                                      G     
compute-0-0: arch                                  x86_64                                   H     
compute-0-0: bio                                   true                                     A     
compute-0-0: dhcp_filename                         pxelinux.0                               A     
compute-0-0: dhcp_nextserver                       10.1.1.1                                 A     
compute-0-0: exec_host                             true                                     A     
compute-0-0: ganglia_address                       224.0.0.3                                G     
compute-0-0: hostname                              compute-0-0                              I     
compute-0-0: kickstartable                         yes                                      A     
compute-0-0: managed                               true                                     A     
compute-0-0: os                                    linux                                    H     
compute-0-0: rack                                  0                                        I     
compute-0-0: rank                                  0                                        I     
compute-0-0: rocks_version                         5.4                                      G     
compute-0-0: sge                                   true                                     A     
compute-0-0: ssh_use_dns                           true                                     G     
compute-0-0: submit_host                           false                                    A     
compute-0-0: tripwire_mail                         root@brunoland.rocksclusters.org         G     
compute-0-0: vm_mac_base_addr                      9a:58:ca:0:00:00                         G     
compute-0-0: vm_mac_base_addr_mask                 ff:ff:ff:c0:00:00                        G
]]>
</screen>

<para>
In the output above, the letters in the 'SOURCE' column indicate the level
at which this host got the attribute.
'G' means the attribute is global, 'O' is an OS attribute, 'A' is an appliance
attribute, 'H' is a host attribute and 'I' in an intrinsic attribute (these
attributes cannot be removed or modified).
</para>

<para>
If a host has an attribute assigned to it, you can use it in a post section
by referring to it in its entity form ("&amp;attribute_name;").
For example, if you'd like to dynamically get the IP address of the private
network for the frontend, you'd use "&amp;Kickstart_PrivateAddress;" in a post
section.
</para>

<para>
Attributes can also be used as a "edge conditional" in graph XML files or
as a "post section conditional" in node XML files.
An edge conditional is used to conditionally traverse an edge in graph XML
file.
The following is an excerpt from the Base Roll graph XML file:
</para>

<screen>
<![CDATA[
<edge from="client" to="x11" cond="x11"/>
]]>
</screen>

<para>
If the "x11" attribute is set to "true", then when a kickstart file is built
for a "client" host (e.g., a compute node or tile node), then the kickstart
file generation code will traverse the edge from client to x11, that is, 
the x11 node XML file will be included in the kickstart file.
Otherwise, if the x11 attribute is set to false, then the x11 node XML file
will not be included in the kickstart file.
</para>

<para>
Post section conditions are used to conditionally execute post sections.
The following is an excerpt from a SGE node XML file:
</para>

<screen>
<![CDATA[
<post os="linux" cond="exec_host">

<file name="/etc/rc.d/rocksconfig.d/post-91-sge" mode="append">
SET_HOST_TYPE=" -x "
</file>

</post>
]]>
</screen>

<para>
If the attribute "exec_host" is true, then the post section will be executed,
otherwise, this post section will be skipped.
</para>

</section>


</section>


</chapter>
